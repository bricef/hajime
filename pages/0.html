<h1>0. An introduction to Clojure</h1>

<p>
Welcome to the Clojure workshop of Cambridge Software Craftsmanship's Seven Language in Seven Workshops Series.
</p>

<h2>What this workshop is about</h2>

<p>The aim of this workshop is to introduce you to Clojure. I hope that you'll walk away understanding a little bit more about what Clojure is, and having learnt some of the key concept of the language. I also hope that you'll know where to find more information and how Clojure could fit in your toolbox.</p>

<p>The aim is <em>not</em> to teach you clojure. </p>
<p>The aim is <em>not</em> to help you set up a clojure environment. </p>
<p>The aim is <em>not</em> to introduce the tooling or the ecosystem around Clojure. </p>

<p>These are all worthy and interesting things, but we'll not be discussing them at all in this session. There are lots of great resource to do this online and in print. At the end of this workshop, we'll provide you with a series of links to further resources that will cover these topics.</p>


<h2>Clojure?</h2>

<p><a href="http://clojure.org">Clojure</a> is a 6 year old Lisp for the JVM, it's powerful, expressive and opinionated. It is the brainchild of <a href="http://en.wikipedia.org/wiki/Rich_Hickey">Rich Hickey</a> with contributions from many others. While the core language is stable and small, the tooling and ecosystem are still rapidly evolving. </p>

<p>So why am I giving this workshop? Because clojure is <em>fun!</em> </p>

<p>I'm still very much a novice programmer in general, an even more so with Clojure, but I've never enjoyed programming more with another language. So I wanted to share. Most of the interesting examples and explanations in this workshop are mostly me <s>shamelessly stealing from</s> being inspired by cleverer and more experienced people. </p>

<p>I will note here that clojure tooling is not particularly newbie friendly compared to other languages. This observation is in general true of Clojure. A lot of the design choices where made to make the life of an experienced developer easy, rather than a new programmer. In my opinion, Clojure is not a good first language, perhaps even not a good second language. I've tried to reduce friction as much as possible by building this environment, but some of the complexity may leak through. It's worthwhile to note that the difficulties with starting are more than repaid when you start throwing real problems at the language.</p>

<h2>Workshop?</h2>

<p>This workshop is divided into two major sections. In the first half we'll talk about some of the key features of Lisp, and show how they're implemented in Clojure and what it means for the language. In the second, we'll talk about some key features of Clojure, and how they can make your life easier when dealing with real world problems.</p>

<p>The entire thing <em>should</em> take us about two hours. I have no idea what will actually happen when we run through it :)</p>


<h1>1. What makes Lisp Lisp</h1>
<h2>Historical Detour</h2>

<p>I'm actually going to start with a historical detour, first because it's interesting, but also because it's relevant and will illuminate some of the key aspects of Lisp and functional programming in general.</p>

<p>The entire thing actually starts in the 1600s with mathematicians who wore outrageous wigs. But to keep things brief, we'll start our story in 1928 when <a href="http://en.wikipedia.org/wiki/David_Hilbert">David Hilbert</a> poses the 'Entscheidungsproblem'. It asks, according to wikipedia "... whether a given statement is provable from the axioms using the rules of logic".</p>

<p>This is pretty heady stuff! At this point we're really still at the blurry edge where Mathematics and Philosophy rub elbows, and two mathematicians are about to lay down the foundation to the craft of programming.</p>

<p>To even begin to answer the problem, the notion of 'algorithm' has to be formally defined, and in 1936 both <a href="http://en.wikipedia.org/wiki/Alonzo_Church">Alonzo Church</a> and <a href="http://en.wikipedia.org/wiki/Alan_Turing">Alan Turing</a> independently come up with their own answers to the problem.</p>

<p>Turing's answer is based on what quickly becomes known as 'the Turing machine'. A relatively simple construct that is still capable of describing any possible computation. </p>

<p>Church's answer is much more mathematical, and relies on a formal system he creates for the purpose. This system is Lambda calculus. Lambda calculus is also general, but instead of dealing with the mutation of a tape in a machine it deals with the composition of functions.</p>

<p>We now have two equivalent models of computation, driven by two incredibly talented mathematicians, both at Princeton. The future of computation hangs in the balance and could go either way. </p> 

<p>But fate intervenes. Nazi germany invades Poland, and war breaks out in Europe.</p>

<p>Turing returns to England to work on code breaking. From his efforts and the work of Von Neumann, the modern computer is born in a bid to break German codes. The ideas of Turing, and the manner in which computation is carried out, is now the default manner in which computers are reasoned about and programmed.</p>

<p>Almost twenty years pass before lambda calculus returns to our story. In 1958, <a href="http://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)">John McCarthy</a> writes a theoretical paper on the computation of recursive function. <a href="https://en.wikipedia.org/wiki/Steve_Russell">Steve Russell</a> reads the paper and realises that the 'eval' function can be implemented in machine code. This is the first Lisp interpreter. </p>

<p>There are now two high level languages available to programmers: Fortran which embodies the ideas of Turing, and Lisp, which embodies those of Church.</p>

<p>Today, we can still observe the legacy of these two models of computation in the languages we use. A direct thread connects the ideas of Turing to C, and then OOP as examplified in C# and Java. </p>

You can still see the legacy of the turing machine and the VN computer in today's languages. there's a direct link between these and modern languages like Java or C#, but lisp is a 
different beast entirely. 
stems from a different approach to understanding computation (understanding computation book) by John McCarthy in 1958. Some weird abstract paper that the author had relegated to the theory pile (studying computation)
Steve russell (who was a grad student at the time iirc, reads the paper and goes "Yeah... I can build eval" and does so in machien code. That was the first lisp interpreter. It's interesting to note that Steve Russel also wrote Spaecwars! the first computer game worthy of the name. 
So lisp is Basically executable lambda calculus.

<h3>1.1. OMG Parentheses!</h3>
Ok, so the first thing that you'll notice is the weird-ass syntax of the language. I have to mention it first, or it will feel really jarring.
This is because Lisp is homoiconic. Homoicowhat? 

http://clojuredocs.org/

IF, cond, let

example: 
 - (println "foo")
 - (35/61)
 - arbitrary numbers
 - list vector map () [] {}

; This is Clojure code.
; When a set is used as a function, it returns the argument if it is
; in the set and nil otherwise.  When used in a boolean context,
; that indicates whether the argument is in the set.
(def vowel? (set "aeiou"))

(defn pig-latin [word] ; defines a function
  ; word is expected to be a string
  ; which can be treated like a sequence of characters.
  (let [first-letter (first word)] ; assigns a local binding
    (if (vowel? first-letter)
      (str word "ay") ; then part of if
      (str (subs word 1) first-letter "ay")))) ; else part of if

(println (pig-latin "red"))
(println (pig-latin "orange"))

Excercise: try stuff out
real example:  vector, list, 

<h3>Lisp is functional</h3>
Impure
What do I mean by functional:
first class function
 - function as arguments 
 - functions as return value
"Concerns and facilitates the application and composition of functions"

for example, an if statement in another language becomes an if Expression that has a value. It returns something. this makes it much more composable

But really, it's about statelessness :
recursion instead of side-effect looping
Avoids state and mutable data.
statelessness

there's lots of other topics in this: purity, immutability, recursion, laziness, referential transparency

OO is domain as set of nouns
FP is domain as composition of verbs

function definiton, lambdas higher order map, reduce, filter (we saw how to implement those in the haskell workshop, and the code translates remarkably well. to give an idea, here's how map is actually implemented: 

immutability: flipbook vs draw+erase example

Flipbook inneficient -> okasaki functional datastructures

Side effects are useful, but functional style isolates rather than eliminate state changes.

convention based mark for purity: 'foo! vs foo'

interleave, take, repeat, cycle functions on collections

example: data filtering with additional complication introduce the ->> and -> oper in clojure
excercise: FIZZBUZZ++
real example: ring middleware

doall dorun doseq ( more advanced)

<h3>Lisp has macros</h3>
technically, this isn't neccessary, but it would be very strange for this not be in a lisp...

It's a bit strange to introduce the topic so early. It would be like starting with the toughest bit, but this is just about planting the seed that will grow into something else. 

Macros are code transformations.

Since the syntax is s expr, macros actually take in a list representing the code and return a list representing the result.

What macros are actually useful for is to add new constructs to the language. Unlike in other languages, if a feature is missing, you have the power to add it. 

let's imagine we want to write an unless (this is a typical macro example)

We could try writing 
; this will fail
(defn unless [condition form]
  (if expr nil form))

(unless false (prn "should print"))
(unless true (prn "should not print"))

Why is this going wrong? function arguments are evaluated. The lazyness of the sequences doesn't reach all this way.

Macros do not evaluate their arguments the way functions do. instead, they transform their arguments, and you control the expression order.

so, for unless

(unless expr form) -> (if expr nil form)

(defmacro unless [expr form]
  (list 'if expr nil form))

REAL EXAMPLE:


(defmacro and
  "Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn't evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true."
  {:added "1.0"}
  ([] true)
  ([x] x)
  ([x & next]
   `(let [and# ~x]
      (if and# (and ~@next) and#))))

(defmacro or
  "Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn't
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil."
  {:added "1.0"}
  ([] nil)
  ([x] x)
  ([x & next]
      `(let [or# ~x]
         (if or# or# (or ~@next)))))

(defmacro ->>
  "Threads the expr through the forms. Inserts x as the
  last item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  last item in second form, etc."
  {:added "1.1"} 
  ([x form] (if (seq? form)
              (with-meta `(~(first form) ~@(next form)  ~x) (meta form))
              (list form x)))
  ([x form & more] `(->> (->> ~x ~form) ~@more)))


<h2>2. What makes Clojure Clojure</h2>
<h3>2.1. On the JVM tight with Java</h3>
Tigth Java interop
both clojure2java but also java2clojure

(import '(java.util Calendar GregorianCalendar))
(def calendar (new GregorianCalendar 2008 Calendar/APRIL 16)) ; April 16, 2008
(def calendar (GregorianCalendar. 2008 Calendar/APRIL 16))
(.add calendar Calendar/MONTH 2)
(.get calendar Calendar/MONTH) ; -> 7


(. (. calendar getTimeZone) getDisplayName) ; long way
(.. calendar getTimeZone getDisplayName) ; -> "Central Standard Time"
(->> calendar (.getTimeZone) (.getDisplay))
(doto calendar
  (.set Calendar/YEAR 1981)
  (.set Calendar/MONTH Calendar/AUGUST)
  (.set Calendar/DATE 1))

(. Class method argument*)
(. instance method argument*)

(new  java.util.Date)
(new java.util.Timer false)


<h3>2.2. Built for concurrency</h3>

http://www.infoq.com/presentations/Concurrency-Clojure

### Vars - like in others, thread isolated. but we'll skip over some of the intricacies.
mutability within a thread. reference. 

#### Refs -sharing state between threads in synchronous coordinated
This is the STM you might have heard about. Essentially behind the scenes, clojure runs its memory like a git tree. (remember it's all immutable.)

(Transaction with dosync )

http://clojure.org/Refs

#### Agents - states between threads in async, independent
Agents Kick ass. it's a shame they don't make it in most tutorials.
http://clojure.org/agents

Clojure agents are basically magic.

it reverses the usual idea. Agents in clojure wrap around value. You send functions to them. the value referenced by the agent gets updated by the function this is done atomically behind the scenes. guarantees consistent view.  The function can be anything. this is far most powerful than the usual agent syntax/systems, 

(more advanced: validation fn, change listeners)

the value can be accessed at any time by anyone, without cost, plays well with STM and dosync.

#### Atoms - shared synchronous independent

(atom foo)

get the state with 

(deref foo) or @foo

 by using swap 

A great example of atoms is the memoizing higher order function. 

(defn memoize [f]
  (let [mem (atom {})]
    (fn [& args]
      (if-let [e (find @mem args)]
        (val e)
        (let [ret (apply f args)]
          (swap! mem assoc args ret)
          ret)))))
 
(defn fib [n]
  (if (<= n 1)
    n
    (+ (fib (dec n)) (fib (- n 2)))))
 
(time (fib 35))
user=> "Elapsed time: 941.445 msecs"
 
(def fib (memoize fib))
 
(time (fib 35))
 
user=> "Elapsed time: 0.044 msecs"

<h3></h3>


<h2>In CLosing</h2>

What we haven't mentioned:
 * clojure runs in your browser: clojurescript
 * it runs on the CLR
 * namespaces
 * metadata
 * 
 <h2>Further Resources</h2>
 <h3>Videos</h3>
http://www.youtube.com/watch?v=Aoeav_T1ARU
 * http://vimeo.com/channels/fulldisclojure/
 * http://www.youtube.com/user/clojuretv
 http://rubymanor.org/3/videos/programming_with_nothing/ tom stuart lambda calculus
 <h3>Tutorials and excercises</h3>
http://java.ociweb.com/mark/clojure/article.html#Intro
https://github.com/functional-koans/clojure-koans
http://www.4clojure.com/problems
 <h3>Books</h3>
 The joy of clojure
 programming clojure
 Clojure programming
 On Lisp
 Functional Datastructures
 Understanding Computation
 The Annotated Turing
 SCIP
 <h3>Resources</h3>
Test frameworks exist: clojure.test Midje


<h2>Credits</h2>


