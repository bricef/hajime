<h1>0. An introduction to Clojure</h1>

<p>
Welcome to the Clojure workshop of Cambridge Software Craftsmanship's Seven Language in Seven Workshops Series.
</p>

<h2>What this workshop is about</h2>

<p>The aim of this workshop is to introduce you to Clojure. I hope that you'll walk away understanding a little bit more about what Clojure is, and having learnt some of the key concept of the language. I also hope that you'll know where to find more information and how Clojure could fit in your toolbox.</p>

<p>The aim is <em>not</em> to teach you clojure. </p>
<p>The aim is <em>not</em> to help you set up a clojure environment. </p>
<p>The aim is <em>not</em> to introduce the tooling or the ecosystem around Clojure. </p>

<p>These are all worthy and interesting things, but we'll not be discussing them at all in this session. There are lots of great resource to do this online and in print. At the end of this workshop, we'll provide you with a series of links to further resources that will cover these topics.</p>


<h2>Clojure?</h2>

<p><a href="http://clojure.org">Clojure</a> is a 6 year old Lisp for the JVM, it's powerful, expressive and opinionated. It is the brainchild of <a href="http://en.wikipedia.org/wiki/Rich_Hickey">Rich Hickey</a> with contributions from many others. While the core language is stable and small, the tooling and ecosystem are still rapidly evolving. </p>

<p>So why am I giving this workshop? Because clojure is <em>fun!</em> </p>

<p>I'm still very much a novice programmer in general, an even more so with Clojure, but I've never enjoyed programming more with another language. So I wanted to share. Most of the interesting examples and explanations in this workshop are mostly me <s>shamelessly stealing from</s> being inspired by cleverer and more experienced people. </p>

<p>I will note here that clojure tooling is not particularly newbie friendly compared to other languages. This observation is in general true of Clojure. A lot of the design choices where made to make the life of an experienced developer easy, rather than a new programmer. In my opinion, Clojure is not a good first language, perhaps even not a good second language. I've tried to reduce friction as much as possible by building this environment, but some of the complexity may leak through. It's worthwhile to note that the difficulties with starting are more than repaid when you start throwing real problems at the language.</p>

<h2>Workshop?</h2>

<p>This workshop is divided into two major sections. In the first half we'll talk about some of the key features of Lisp, and show how they're implemented in Clojure and what it means for the language. In the second, we'll talk about some key features of Clojure, and how they can make your life easier when dealing with real world problems.</p>

<p>The entire thing <em>should</em> take us about two hours. I have no idea what will actually happen when we run through it :)</p>


<h1>1. What makes Lisp Lisp</h1>
<h2>Historical Detour</h2>

<p>I'm actually going to start with a historical detour, first because it's interesting, but also because it's relevant and will illuminate some of the key aspects of Lisp and functional programming in general.</p>

<p>The entire thing actually starts in the 1600s with mathematicians who wore outrageous wigs. But to keep things brief, we'll start our story in 1928 when <a href="http://en.wikipedia.org/wiki/David_Hilbert">David Hilbert</a> poses the 'Entscheidungsproblem'. It asks, according to wikipedia "... whether a given statement is provable from the axioms using the rules of logic".</p>

<p>This is pretty heady stuff! At this point we're really still at the blurry edge where Mathematics and Philosophy rub elbows, and two mathematicians are about to lay down the foundation to the craft of programming.</p>

<p>To even begin to answer the problem, the notion of 'algorithm' has to be formally defined, and in 1936 both <a href="http://en.wikipedia.org/wiki/Alonzo_Church">Alonzo Church</a> and <a href="http://en.wikipedia.org/wiki/Alan_Turing">Alan Turing</a> independently come up with their own answers to the problem.</p>

<p>Turing's answer is based on what quickly becomes known as 'the Turing machine'. A relatively simple construct that is still capable of describing any possible computation. </p>

<p>Church's answer is much more mathematical, and relies on a formal system he creates for the purpose. This system is Lambda calculus. Lambda calculus is also general, but instead of dealing with the mutation of a tape in a machine it deals with the composition of functions.</p>

<p>We then had two equivalent models of computation, driven by two incredibly talented mathematicians, both at Princeton. The future of computation hung in the balance and could go either way. </p> 

<p>But fate intervenes. Nazi germany invades Poland, and war breaks out in Europe.</p>

<p>Turing returns to England to work on code breaking. From his efforts and the work of Von Neumann, the modern computer is born in a bid to break German codes. The ideas of Turing, and the manner in which computation is carried out, is now the default manner in which computers are reasoned about and programmed.</p>

<p>Almost twenty years pass before lambda calculus returns to our story. In 1958, <a href="http://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)">John McCarthy</a> writes a theoretical paper on the computation of recursive function. <a href="https://en.wikipedia.org/wiki/Steve_Russell">Steve Russell</a> reads the paper and realises that the 'eval' function can be implemented in machine code. This is the first Lisp interpreter. </p>

<p>There are now two high level languages available to programmers: Fortran which embodies the ideas of Turing, and Lisp, which embodies those of Church.</p>

<p>Today, we can still observe the legacy of these two models of computation in the languages we use. For example, a direct thread connects the ideas of Turing to C, and then onto OOP as examplified in C# and Java. </p>

<p>Similarly, the ideas of lambda calculus are evident in Lisp and functional languages. If you want to better understand this, there is a <a href="http://codon.com/programming-with-nothing">great talk</a> by Tom Stuart that uses Ruby to explore lambda calculus.</p>

<p>In essence, Lisp stems from a different place than most other programming languages, and is based on a radically different model of computation. It is interesting to note that as machines have grown more powerful and languages have evolved, they have moved slowly closer to Lisp and further away from the Turing paradigm. This is a long running trend, starting with conditionals (yes, that's right) being introduced into Algol by McCarthy from Lisp. Other features that have slowly migrated into mainstream languages and we now take for granted but had their beginnings in Lisp are first order functions, recursion and garbage collection!</p>


<h2>1.1. OMG Parentheses!</h2>
<p>The first thing that any programmer notices when seeing Lisp code for the first time is the radically different syntax. All those parentheses are rather jarring to people used to syntax inspired by C.</p>


<h3>Basic Syntax</h3>
<p>We'll start slow and finish by talking a bit more about what the strange syntax gives us.</p>

<p>Let's start by adding doing some basic math. Try to type <code>(+ 3 3)</code> in the REPL.</p>

<p>This should return the expected answer. </p>

<p>Let's try a few more things:</p>

<ul>
  <li><code>(/ 10 3)</code></li>
  <li><code>(+ 1 2 3 4 5 6)</code></li>
  <li><code>(println "Hello, World!")</code></li>
  <li><code>(format "Hello, %s!" "bob")</code></li>
  <li><code>(if (< 3 2) "My value if true" "my value if false")</code></li>
  <li><code>(list 1 2 3 4 5 6)</code></li>
  <li><code>'(1 2 3 4 5 6)</code></li>
</ul>

<h3>Datastructures</h3>
<p>We also have rich data structures, like maps. Maps are quite interesting, since they can be used like functions for lookup. For example this is how we define a map:</p>

<pre class="code">{"first-key" "first-value" 
"second-key" "second-value"}</pre>

<p>Maps are a little more powerful than in other languages</p>

<pre class="code">({:a 1 :b 2} :a)</pre>

<p> We're also introducing keywords above. 
 Keywords follow the same syntax rules 
 as symbols, but start with a colon. 
 They're more efficient than either symbols
 or string when used for comparison and lookup</p>

<div class="code">; keywords can also be used for lookup.
(:a {:a 1 :b 2})

; but there's a more traditional syntax too
(get {:a 1 :b 2} :a)</div>

<p>Data structures are actually much Richer! Have a look at <a href="http://clojure.org/data_structures">the documentation</a>, which goes through this in much more details.</p>

<h3>Defining Functions</h3>
<p>Defining functions is easy!<p>

<pre class="code">(defn square [x]
  (* x x))</pre>

<p>Should be obvious how to define your own.</p>

<h3>Excercise: Fibonacci numbers</h3>
<p>For our first excercise, we'll tackle the classic Fibonacci numbers. We'll eventually return to this problem and make our approach much more efficient without changing our code. But first, we will solve it without worrying about efficiency.</p>

<p>The mathematical definition of Fibonacci numbers is as follows:</p>

<p>F<sub>n</sub>=F<sub>n-1</sub>+F<sub>n-2</sub></p>

<p>With seed values F<sub>0</sub>=0 and F<sub>1</sub>=1</p>

<p>You must complete the function below by replacing '_' with the appropriate form:</p>

<div class="code">(defn fib [n]
  _)</div>

<p>You can use the following to test your solution:</p>

<div class="code">(def fib-tests `[
  (1 1)
  (2 1)
  (12 144)
  (13 233)
  (25 75025)
])

(defn is-fib? [func]
  "Does my argument behave as we expect the fibonacci function to?"
  (let [tests fib-tests
       got (map func (map first tests))
       expected (map second tests)
       same (map #(= (first %) (second %)) (map vector got expected))]
    (every? identity same)))</div>

<p>Which you can use by running <code>(is-fib? fib)</code>.</p>

<h3>Solution: Fibonacci numbers</h3>
<div class="code">(defn fib [n]
  (if (<= n 1)
    n
    (+ (fib (dec n)) (fib (- n 2)))))
</div>









<h3>Lisp is functional</h3>
<p>What is functional?</p>

<blockquote>Concerns and facilitates the application and composition of functions<br /><small>Fogus & Houser, The Joy of Clojure</small></blockquote>

<p>In particular, functions should be first class oblects that can be passed as arguments to a function and returned from a function.<p>

<p>We've actually already seen this, when we tested the Fibonacci function, the test took an arbitrary function as input and checked that it behaved the way we expect the fibonacci function to behave.</p>

<p>So why is this important?</p>

<p>Side effects are useful. In fact, they're usually why we run programs in the first place. However, they are difficult to reason about. For example, a function call in C or Java could do all sorts of things to the memory/object. If the function is incorrect, we may only find out about it much later, making debugging much harder.<p>

<p>Writing functional code does not eliminate statefulness and state changes, but isolates and constrains them to make the program easier to reason about.</p>

<p>for example, an if <em>statement</em> in another language becomes an if <em>expression</em> that has returns a value. This makes the language much more composable. We can now use an if expression as an argument to a function!</p>

<p>Really, this is an exercise in minimising mutable state. Clojure's collections are very good at this, and there is a lot of clever things going on below the covers to make immutable state efficient. </p> 

<p>Clojure itself is pragmatic about side effects. It provides the tools to write functional code, but is not dogmatic. It simply makes the functional style the default and most natural way to write programs.</p>

<p>For example, it makes recursion the natural way to express algorithms, rather than side-effect base loopings, and provides a nice syntax for anonymous functions.</p>

<!-- Flipbook example
immutability: flipbook vs draw+erase example
Flipbook inneficient -> okasaki functional datastructures -->

<!--there's lots of other topics in this: purity, immutability, recursion, laziness, referential transparency-->

<!--OO is domain as set of nouns
FP is domain as composition of verbs-->

<p>For example, functions in Clojure are anonymous by default, and <code>defn</code> is just syntactic sugar which does the same as:</p>

<div class="code">(def name (fn [args] body))</div>

<p>Thiss is where we can start to see the roots of Lisp in Lambda Calculus.</p>

<p>We also have a clean syntax to shorten function definitions even further:</p>

<div class="code">#(...)</div>

<p>This is in fact all you need to be 'Turing Complete' and the entire power of the language lies almost entirely in the ability to manipulate functions like this.</p>

<p>On a more practical note, this syntax is really useful when using higher order functions. (Functions that take functions as arguments). For example, using map to square every number in a sequence:</p>

<div class="code">(map #(* % %) [1 2 3 4 5 6])</div>

<p>We looked at implementing these higher order functions in the Haskell workshop, and the code translates remarkably well. To give you an idea, here is a bare-bones implementation of map:</p> 

<div class="code">(defn simple-map [f coll] 
  (cons 
    (f (first coll)) 
    (map f (rest coll)))</code>

<p>This doesn't handle all edge cases, however. Modify it to handle at least empty lists. </p>

<h3>Lazy Collections</h3>
<p>Clojure also uses lazy collections. This means that the values in the colection are only evaluated when needed. For example, try running <code>(repeat 3)</code> in the repl. What happens?</p>

<p>Now try running <code>(take 5 (repeat 3))</code>. </p>

<p>There are other functions that work with lazy collections:</p>

<ul>
  <li>interleave</li>
  <li>repeat</li>
  <li>cycle</li>
</ul>

<p>You can have a look at the collection API for more.</p>

<!--example: data filtering with additional complication introduce the ->> and -> oper in clojure-->

<h3>Excercise: Standard Deviation</h3>
<p>With what we have learnt so far, we should have enough to implement a function that calculates the standard deviation of a list of numbers. You can use <a href="http://clojuredocs.org/quickref/Clojure%20Core">this reference sheet</a> to explore the clojure functions you might need. The standard deviation is defined as:</p>

<blockquote>Root of the Average of the square differences from the mean</blockquote>

<h3>Solution: Standard Deviation</h3>

<div class="code">
(defn std-dev [samples]
  (let [n (count samples)
        mean (/ (reduce + samples) n)
        intermediate (map #(Math/pow (- %1 mean) 2) samples)]
    (Math/sqrt 
    (/ (reduce + intermediate) n))))
</div>

<h3>Excercise: FizzBuzz</h3>

excercise: FIZZBUZZ++
real example: ring middleware

doall dorun doseq ( more advanced)

<h3>Lisp has macros</h3>
technically, this isn't neccessary, but it would be very strange for this not be in a lisp...

It's a bit strange to introduce the topic so early. It would be like starting with the toughest bit, but this is just about planting the seed that will grow into something else. 

Macros are code transformations.

Since the syntax is s expr, macros actually take in a list representing the code and return a list representing the result.

What macros are actually useful for is to add new constructs to the language. Unlike in other languages, if a feature is missing, you have the power to add it. 

let's imagine we want to write an unless (this is a typical macro example)

We could try writing 
; this will fail
(defn unless [condition form]
  (if expr nil form))

(unless false (prn "should print"))
(unless true (prn "should not print"))

Why is this going wrong? function arguments are evaluated. The lazyness of the sequences doesn't reach all this way.

Macros do not evaluate their arguments the way functions do. instead, they transform their arguments, and you control the expression order.

so, for unless

(unless expr form) -> (if expr nil form)

(defmacro unless [expr form]
  (list 'if expr nil form))

REAL EXAMPLE:


(defmacro and
  "Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn't evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true."
  {:added "1.0"}
  ([] true)
  ([x] x)
  ([x & next]
   `(let [and# ~x]
      (if and# (and ~@next) and#))))

(defmacro or
  "Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn't
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil."
  {:added "1.0"}
  ([] nil)
  ([x] x)
  ([x & next]
      `(let [or# ~x]
         (if or# or# (or ~@next)))))

(defmacro ->>
  "Threads the expr through the forms. Inserts x as the
  last item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  last item in second form, etc."
  {:added "1.1"} 
  ([x form] (if (seq? form)
              (with-meta `(~(first form) ~@(next form)  ~x) (meta form))
              (list form x)))
  ([x form & more] `(->> (->> ~x ~form) ~@more)))


<h2>2. What makes Clojure Clojure</h2>
<h3>2.1. On the JVM tight with Java</h3>
Tigth Java interop
both clojure2java but also java2clojure

(import '(java.util Calendar GregorianCalendar))
(def calendar (new GregorianCalendar 2008 Calendar/APRIL 16)) ; April 16, 2008
(def calendar (GregorianCalendar. 2008 Calendar/APRIL 16))
(.add calendar Calendar/MONTH 2)
(.get calendar Calendar/MONTH) ; -> 7


(. (. calendar getTimeZone) getDisplayName) ; long way
(.. calendar getTimeZone getDisplayName) ; -> "Central Standard Time"
(->> calendar (.getTimeZone) (.getDisplay))
(doto calendar
  (.set Calendar/YEAR 1981)
  (.set Calendar/MONTH Calendar/AUGUST)
  (.set Calendar/DATE 1))

(. Class method argument*)
(. instance method argument*)

(new  java.util.Date)
(new java.util.Timer false)


<h3>2.2. Built for concurrency</h3>

http://www.infoq.com/presentations/Concurrency-Clojure

### Vars - like in others, thread isolated. but we'll skip over some of the intricacies.
mutability within a thread. reference. 

#### Refs -sharing state between threads in synchronous coordinated
This is the STM you might have heard about. Essentially behind the scenes, clojure runs its memory like a git tree. (remember it's all immutable.)

(Transaction with dosync )

http://clojure.org/Refs

#### Agents - states between threads in async, independent
Agents Kick ass. it's a shame they don't make it in most tutorials.
http://clojure.org/agents

Clojure agents are basically magic.

it reverses the usual idea. Agents in clojure wrap around value. You send functions to them. the value referenced by the agent gets updated by the function this is done atomically behind the scenes. guarantees consistent view.  The function can be anything. this is far most powerful than the usual agent syntax/systems, 

(more advanced: validation fn, change listeners)

the value can be accessed at any time by anyone, without cost, plays well with STM and dosync.

#### Atoms - shared synchronous independent

(atom foo)

get the state with 

(deref foo) or @foo

 by using swap 

A great example of atoms is the memoizing higher order function. 

(defn memoize [f]
  (let [mem (atom {})]
    (fn [& args]
      (if-let [e (find @mem args)]
        (val e)
        (let [ret (apply f args)]
          (swap! mem assoc args ret)
          ret)))))
 
(defn fib [n]
  (if (<= n 1)
    n
    (+ (fib (dec n)) (fib (- n 2)))))
 
(time (fib 35))
user=> "Elapsed time: 941.445 msecs"
 
(def fib (memoize fib))
 
(time (fib 35))
 
user=> "Elapsed time: 0.044 msecs"

<h3></h3>


<h2>In CLosing</h2>

What we haven't mentioned:
 * clojure runs in your browser: clojurescript
 * it runs on the CLR
 * namespaces
 * metadata
 * 
 <h2>Further Resources</h2>
 <h3>Videos</h3>
http://www.youtube.com/watch?v=Aoeav_T1ARU
 * http://vimeo.com/channels/fulldisclojure/
 * http://www.youtube.com/user/clojuretv
 http://rubymanor.org/3/videos/programming_with_nothing/ tom stuart lambda calculus
 <h3>Tutorials and excercises</h3>
http://java.ociweb.com/mark/clojure/article.html#Intro
https://github.com/functional-koans/clojure-koans
http://www.4clojure.com/problems
 <h3>Books</h3>
 The joy of clojure
 programming clojure
 Clojure programming
 On Lisp
 Functional Datastructures
 Understanding Computation
 The Annotated Turing
 SCIP
 <h3>Resources</h3>
http://clojuredocs.org/
Test frameworks exist: clojure.test Midje


<h2>Credits</h2>


